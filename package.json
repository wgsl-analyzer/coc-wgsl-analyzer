{
  "name": "coc-wgsl-analyzer",
  "version": "0.82.1",
  "description": "wgsl-analyzer for Vim/Neovim, works as an extension with coc.nvim",
  "license": "MIT",
  "main": "lib/index.js",
  "keywords": [
    "coc.nvim"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/wgsl-analyzer/coc-wgsl-analyzer.git"
  },
  "engines": {
    "coc": "^0.0.80"
  },
  "activationEvents": [
    "onLanguage:wgsl",
    "onLanguage:wesl",
    "workspaceContains:wesl.toml",
    "workspaceContains:*/wesl.toml",
    "workspaceContains:wgsl-project.json",
    "workspaceContains:*/wgsl-project.json",
    "workspaceContains:.wgsl-project.json",
    "workspaceContains:*/.wgsl-project.json"
  ],
  "scripts": {
    "check": "biome check src",
    "format": "biome format --write",
    "schema": "node ./generate-config-schema.js",
    "build": "node esbuild.mjs",
    "watch": "node esbuild.mjs --watch",
    "prepare": "node esbuild.mjs"
  },
  "devDependencies": {
    "@biomejs/biome": "^2.1.1",
    "@types/adm-zip": "^0.5.7",
    "@types/node": "^16.18.126",
    "@types/node-fetch": "^3.0.2",
    "@types/which": "^3.0.4",
    "adm-zip": "^0.5.16",
    "coc.nvim": "^0.0.83-next.24",
    "esbuild": "^0.25.6",
    "https-proxy-agent": "^7.0.6",
    "node-fetch": "^3.3.2",
    "typescript": "^5.8.3",
    "vscode-languageserver-protocol": "^3.17.5",
    "which": "^5.0.0"
  },
  "prettier": {
    "singleQuote": true,
    "printWidth": 180,
    "semi": true
  },
  "contributes": {
    "rootPatterns": [
      {
        "filetype": "wgsl",
        "patterns": [
          "wesl.toml",
          "wgsl-project.json"
        ]
      }
    ],
    "jsonValidation": [
      {
        "fileMatch": "wgsl-project.json",
        "url": "https://json.schemastore.org/wgsl-project.json"
      },
      {
        "fileMatch": ".wgsl-project.json",
        "url": "https://json.schemastore.org/wgsl-project.json"
      }
    ],
    "configuration": {
      "type": "object",
      "title": "coc-wgsl-analyzer configuration",
      "properties": {
        "wgsl-analyzer.enable": {
          "type": "boolean",
          "markdownDescription": "Enable `coc-wgsl-analyzer`",
          "default": true
        },
        "wgsl-analyzer.disableProgressNotifications": {
          "type": "boolean",
          "default": false,
          "markdownDescription": "Disable initialization and workdone progress notifications"
        },
        "wgsl-analyzer.disablePullDiagnostic": {
          "type": "boolean",
          "default": true,
          "markdownDescription": "Disable pullDiagnostic feature"
        },
        "wgsl-analyzer.terminal.startinsert": {
          "type": "boolean",
          "default": false,
          "markdownDescription": "Enter insert mode after terminal displayed"
        },
        "wgsl-analyzer.debug.runtime": {
          "type": "string",
          "default": "termdebug",
          "enum": [
            "termdebug",
            "vimspector",
            "nvim-dap"
          ],
          "markdownDescription": "Choose which debug runtime to use",
          "enumDescriptions": [
            "`\"termdebug\"` use vim/neovim builtin debugger - gdb",
            "`\"vimspector\"` use vimspector plugin",
            "`\"nvim-dap\"` use nvim-dap plugin"
          ]
        },
        "wgsl-analyzer.debug.vimspector.configuration.name": {
          "type": "string",
          "default": "launch",
          "markdownDescription": "Specify the name of the vimspector configuration name. The following args will be passed to the configuration: `Executable` and `Args` (both strings)"
        },
        "wgsl-analyzer.debug.nvimdap.configuration.template": {
          "type": "string",
          "default": "",
          "markdownDescription": "Configuration template used to invoked dap.run([conf](https://github.com/mfussenegger/nvim-dap/blob/0e6b7c47dd70e80793ed39271b2aa712d9366dbc/doc/dap.txt#L656C2-L656C2)). The template will be instantiate like thie: `$exe` will be replaced with executable path, `$args` will be replaced with arguments."
        },
        "wgsl-analyzer.server.path": {
          "type": [
            "null",
            "string"
          ],
          "default": null,
          "markdownDescription": "Path to wgsl-analyzer executable (points to bundled binary by default). If this is set, then \"wgsl-analyzer.updates.channel\" setting is not used"
        },
        "wgsl-analyzer.server.extraEnv": {
          "type": [
            "null",
            "object"
          ],
          "default": null,
          "markdownDescription": "Extra environment variables that will be passed to the wgsl-analyzer executable. Useful for passing e.g. `RA_LOG` for debugging."
        },
        "wgsl-analyzer.restartServerOnConfigChange": {
          "markdownDescription": "Whether to restart the server automatically when certain settings that require a restart are changed.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.trace.server": {
          "type": "string",
          "scope": "window",
          "enum": [
            "off",
            "messages",
            "verbose"
          ],
          "enumDescriptions": [
            "No traces",
            "Error only",
            "Full log"
          ],
          "default": "off",
          "markdownDescription": "Trace requests to the wgsl-analyzer"
        },
        "wgsl-analyzer.updates.prompt": {
          "type": [
            "boolean",
            "string"
          ],
          "enum": [
            true,
            false,
            "neverDownload"
          ],
          "default": true,
          "markdownDescription": "Prompt the user before downloading wgsl-analyzer"
        },
        "wgsl-analyzer.updates.checkOnStartup": {
          "type": "boolean",
          "default": true,
          "markdownDescription": "Auto-check wgsl-analyzer updates on startup"
        },
        "wgsl-analyzer.updates.channel": {
          "type": "string",
          "default": "stable",
          "enum": [
            "stable",
            "nightly"
          ],
          "markdownDescription": "Choose `\"nightly\"` updates to get the latest features and bug fixes every day. While `\"stable\"` releases occur weekly and don't contain cutting-edge features from VS Code proposed APIs",
          "enumDescriptions": [
            "`\"stable\"` updates are shipped weekly, they don't contain cutting-edge features from VS Code proposed APIs but have less bugs in general",
            "`\"nightly\"` updates are shipped daily (extension updates automatically by downloading artifacts directly from GitHub), they contain cutting-edge features and latest bug fixes. These releases help us get your feedback very quickly and speed up wgsl-analyzer development **drastically**"
          ]
        },
        "wgsl-analyzer.assist.emitMustUse": {
          "markdownDescription": "Whether to insert #[must_use] when generating `as_` methods\nfor enum variants.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.assist.expressionFillDefault": {
          "markdownDescription": "Placeholder expression to use for missing expressions in assists.",
          "default": "todo",
          "type": "string",
          "enum": [
            "todo",
            "default"
          ],
          "enumDescriptions": [
            "Fill missing expressions with a `todo` comment.",
            "Fill missing expressions with reasonable defaults."
          ]
        },
        "wgsl-analyzer.assist.termSearch.fuel": {
          "markdownDescription": "Term search fuel in \"units of work\" for assists (Defaults to 1800).",
          "default": 1800,
          "type": "integer",
          "minimum": 0
        },
        "wgsl-analyzer.cachePriming.enable": {
          "markdownDescription": "Warm up caches on project load.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.cachePriming.numThreads": {
          "markdownDescription": "How many worker threads to handle priming caches. The default `0` means to pick automatically.",
          "default": "physical",
          "anyOf": [
            {
              "type": "number",
              "minimum": 0,
              "maximum": 255
            },
            {
              "type": "string",
              "enum": [
                "physical",
                "logical"
              ],
              "enumDescriptions": [
                "Use the number of physical cores",
                "Use the number of logical cores"
              ]
            }
          ]
        },
        "wgsl-analyzer.wesl.autoreload": {
          "markdownDescription": "Automatically refresh project info via `wesl metadata` on\n`wesl.toml` or `.wesl/config.toml` changes.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.wesl.cfgs": {
          "markdownDescription": "List of cfg options to enable with the given values.\n\nTo enable a name without a value, use `\"key\"`.\nTo enable a name with a value, use `\"key=value\"`.\nTo disable, prefix the entry with a `!`.",
          "default": [
            "debug_assertions",
            "miri"
          ],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "wgsl-analyzer.wesl.extraArgs": {
          "markdownDescription": "Extra arguments that are passed to every wesl invocation.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "wgsl-analyzer.wesl.extraEnv": {
          "markdownDescription": "Extra environment variables that will be set when running wesl, wgpu\nor other commands within the workspace. Useful for setting WGSLFLAGS.",
          "default": {},
          "type": "object"
        },
        "wgsl-analyzer.wesl.noDeps": {
          "markdownDescription": "Whether to skip fetching dependencies. If set to \"true\", the analysis is performed\nentirely offline, and metadata for dependencies is not fetched.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.checkOnSave": {
          "markdownDescription": "Run the check command for diagnostics on save.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.check.command": {
          "markdownDescription": "wesl command to use for `wesl check`.",
          "default": "check",
          "type": "string"
        },
        "wgsl-analyzer.check.extraArgs": {
          "markdownDescription": "Extra arguments for `wesl check`.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "wgsl-analyzer.check.extraEnv": {
          "markdownDescription": "Extra environment variables that will be set when running `wesl check`.\nExtends `#wgsl-analyzer.wesl.extraEnv#`.",
          "default": {},
          "type": "object"
        },
        "wgsl-analyzer.check.ignore": {
          "markdownDescription": "List of `wesl check` (or other command specified in `check.command`) diagnostics to ignore.\n\nFor example for `wesl check`: `dead_code`, `unused_imports`, `unused_variables`,...",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "wgsl-analyzer.check.invocationStrategy": {
          "markdownDescription": "Specifies the invocation strategy to use when running the check command.\nIf `per_workspace` is set, the command will be executed for each workspace.\nIf `once` is set, the command will be executed once.\nThis config only has an effect when `#wgsl-analyzer.check.overrideCommand#`\nis set.",
          "default": "per_workspace",
          "type": "string",
          "enum": [
            "per_workspace",
            "once"
          ],
          "enumDescriptions": [
            "The command will be executed for each WGSL workspace with the workspace as the working directory.",
            "The command will be executed once with the opened project as the working directory."
          ]
        },
        "wgsl-analyzer.check.overrideCommand": {
          "markdownDescription": "Override the command wgsl-analyzer uses instead of `wesl check` for\ndiagnostics on save. The command is required to output json and\nshould therefore include `--message-format=json` or a similar option\n(if your client supports the `colorDiagnosticOutput` experimental\ncapability, you can use `--message-format=json-diagnostic-rendered-ansi`).\n\nIf you're changing this because you're using some tool wrapping\nwesl-rs, you might also want to change\n`#wgsl-analyzer.wesl.buildScripts.overrideCommand#`.\n\nIf there are multiple linked projects/workspaces, this command is invoked for\neach of them, with the working directory being the workspace root\n(i.e., the folder containing the `wesl.toml`). This can be overwritten\nby changing `#wgsl-analyzer.check.invocationStrategy#`.\n\nIf `$saved_file` is part of the command, wgsl-analyzer will pass\nthe absolute path of the saved file to the provided command. This is\nintended to be used with non-wesl build systems.\nNote that `$saved_file` is experimental and may be removed in the future.\n\nAn example command would be:\n\n```bash\nwesl check --workspace --message-format=json --all-targets\n```\n.",
          "default": null,
          "type": [
            "null",
            "array"
          ],
          "items": {
            "type": "string"
          }
        },
        "wgsl-analyzer.check.targets": {
          "markdownDescription": "Check for specific targets. Defaults to `#wgsl-analyzer.wesl.target#` if empty.\n\nCan be a single target, e.g. `\"x86_64-unknown-linux-gnu\"` or a list of targets, e.g.\n`[\"aarch64-apple-darwin\", \"x86_64-apple-darwin\"]`.\n\nAliased as `\"checkOnSave.targets\"`.",
          "default": null,
          "anyOf": [
            {
              "type": "null"
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "wgsl-analyzer.check.workspace": {
          "markdownDescription": "Whether `--workspace` should be passed to `wesl check`.\nIf false, `-p <package>` will be passed instead if applicable. In case it is not, no\ncheck will be performed.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.completion.autoimport.enable": {
          "markdownDescription": "Toggles the additional completions that automatically add imports when completed.\nNote that your client must specify the `additionalTextEdits` LSP client capability to truly have this feature enabled.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.completion.autoimport.exclude": {
          "markdownDescription": "A list of full paths to items to exclude from auto-importing completions.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "wgsl-analyzer.completion.callable.snippets": {
          "markdownDescription": "Whether to add parenthesis and argument snippets when completing function.",
          "default": "fill_arguments",
          "type": "string",
          "enum": [
            "fill_arguments",
            "add_parentheses",
            "none"
          ],
          "enumDescriptions": [
            "Add call parentheses and pre-fill arguments.",
            "Add call parentheses.",
            "Do no snippet completions for callables."
          ]
        },
        "wgsl-analyzer.completion.fullFunctionSignatures.enable": {
          "markdownDescription": "Whether to show full function/method signatures in completion docs.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.completion.hideDeprecated": {
          "markdownDescription": "Whether to omit deprecated items from autocompletion. By default they are marked as deprecated but not hidden.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.completion.limit": {
          "markdownDescription": "Maximum number of completions to return. If `None`, the limit is infinite.",
          "default": null,
          "type": [
            "null",
            "integer"
          ],
          "minimum": 0
        },
        "wgsl-analyzer.completion.postfix.enable": {
          "markdownDescription": "Whether to show postfix snippets like `dbg`, `if`, `not`, etc.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.completion.privateEditable.enable": {
          "markdownDescription": "Enables completions of private items and fields that are defined in the current workspace even if they are not visible at the current position.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.completion.snippets.custom": {
          "markdownDescription": "Custom completion snippets.",
          "default": {},
          "type": "object"
        },
        "wgsl-analyzer.completion.termSearch.enable": {
          "markdownDescription": "Whether to enable term search based snippets like `Some(foo.bar().baz())`.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.completion.termSearch.fuel": {
          "markdownDescription": "Term search fuel in \"units of work\" for autocompletion (Defaults to 1000).",
          "default": 1000,
          "type": "integer",
          "minimum": 0
        },
        "wgsl-analyzer.diagnostics.disabled": {
          "markdownDescription": "List of wgsl-analyzer diagnostics to disable.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "wgsl-analyzer.diagnostics.enable": {
          "markdownDescription": "Whether to show native wgsl-analyzer diagnostics.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.diagnostics.experimental.enable": {
          "markdownDescription": "Whether to show experimental wgsl-analyzer diagnostics that might\nhave more false positives than usual.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.diagnostics.styleLints.enable": {
          "markdownDescription": "Whether to run additional style lints.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.diagnostics.warningsAsHint": {
          "markdownDescription": "List of warnings that should be displayed with hint severity.\n\nThe warnings will be indicated by faded text or three dots in code\nand will not show up in the `Problems Panel`.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "wgsl-analyzer.diagnostics.warningsAsInfo": {
          "markdownDescription": "List of warnings that should be displayed with info severity.\n\nThe warnings will be indicated by a blue squiggly underline in code\nand a blue icon in the `Problems Panel`.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "wgsl-analyzer.files.exclude": {
          "markdownDescription": "These paths (file/directories) will be ignored by wgsl-analyzer. They are\nrelative to the workspace root, and globs are not supported. You may\nalso need to add the folders to Code's `files.watcherExclude`.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "wgsl-analyzer.files.watcher": {
          "markdownDescription": "Controls file watching implementation.",
          "default": "client",
          "type": "string",
          "enum": [
            "client",
            "server"
          ],
          "enumDescriptions": [
            "Use the client (editor) to watch files for changes",
            "Use server-side file watching"
          ]
        },
        "wgsl-analyzer.highlightRelated.branchExitPoints.enable": {
          "markdownDescription": "Enables highlighting of related return values while the cursor is on any `match`, `if`, or match arm arrow (`=>`).",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.highlightRelated.breakPoints.enable": {
          "markdownDescription": "Enables highlighting of related references while the cursor is on `break`, `loop`, `while`, or `for` keywords.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.highlightRelated.exitPoints.enable": {
          "markdownDescription": "Enables highlighting of all exit points while the cursor is on any `return`, `?`, `fn`, or return type arrow (`->`).",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.highlightRelated.references.enable": {
          "markdownDescription": "Enables highlighting of related references while the cursor is on any identifier.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.highlightRelated.yieldPoints.enable": {
          "markdownDescription": "Enables highlighting of all break points for a loop or block context while the cursor is on any `async` or `await` keywords.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.hover.actions.updateTest.enable": {
          "markdownDescription": "Whether to show `Update Test` action. Only applies when\n`#wgsl-analyzer.hover.actions.enable#` and `#wgsl-analyzer.hover.actions.run.enable#` are set.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.hover.documentation.enable": {
          "markdownDescription": "Whether to show documentation on hover.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.hover.documentation.keywords.enable": {
          "markdownDescription": "Whether to show keyword hover popups. Only applies when\n`#wgsl-analyzer.hover.documentation.enable#` is set.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.hover.dropGlue.enable": {
          "markdownDescription": "Whether to show drop glue information on hover.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.hover.links.enable": {
          "markdownDescription": "Use markdown syntax for links on hover.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.hover.maxSubstitutionLength": {
          "markdownDescription": "Whether to show what types are used as generic arguments in calls etc. on hover, and what is their max length to show such types, beyond it they will be shown with ellipsis.\n\nThis can take three values: `null` means \"unlimited\", the string `\"hide\"` means to not show generic substitutions at all, and a number means to limit them to X characters.\n\nThe default is 20 characters.",
          "default": 20,
          "anyOf": [
            {
              "type": "null"
            },
            {
              "type": "string",
              "enum": [
                "hide"
              ]
            },
            {
              "type": "integer"
            }
          ]
        },
        "wgsl-analyzer.hover.memoryLayout.alignment": {
          "markdownDescription": "How to render the align information in a memory layout hover.",
          "default": "hexadecimal",
          "anyOf": [
            {
              "type": "null"
            },
            {
              "type": "string",
              "enum": [
                "both",
                "decimal",
                "hexadecimal"
              ],
              "enumDescriptions": [
                "Render as 12 (0xC)",
                "Render as 12",
                "Render as 0xC"
              ]
            }
          ]
        },
        "wgsl-analyzer.hover.memoryLayout.enable": {
          "markdownDescription": "Whether to show memory layout data on hover.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.hover.memoryLayout.niches": {
          "markdownDescription": "How to render the niche information in a memory layout hover.",
          "default": false,
          "type": [
            "null",
            "boolean"
          ]
        },
        "wgsl-analyzer.hover.memoryLayout.offset": {
          "markdownDescription": "How to render the offset information in a memory layout hover.",
          "default": "hexadecimal",
          "anyOf": [
            {
              "type": "null"
            },
            {
              "type": "string",
              "enum": [
                "both",
                "decimal",
                "hexadecimal"
              ],
              "enumDescriptions": [
                "Render as 12 (0xC)",
                "Render as 12",
                "Render as 0xC"
              ]
            }
          ]
        },
        "wgsl-analyzer.hover.memoryLayout.padding": {
          "markdownDescription": "How to render the padding information in a memory layout hover.",
          "default": null,
          "anyOf": [
            {
              "type": "null"
            },
            {
              "type": "string",
              "enum": [
                "both",
                "decimal",
                "hexadecimal"
              ],
              "enumDescriptions": [
                "Render as 12 (0xC)",
                "Render as 12",
                "Render as 0xC"
              ]
            }
          ]
        },
        "wgsl-analyzer.hover.memoryLayout.size": {
          "markdownDescription": "How to render the size information in a memory layout hover.",
          "default": "both",
          "anyOf": [
            {
              "type": "null"
            },
            {
              "type": "string",
              "enum": [
                "both",
                "decimal",
                "hexadecimal"
              ],
              "enumDescriptions": [
                "Render as 12 (0xC)",
                "Render as 12",
                "Render as 0xC"
              ]
            }
          ]
        },
        "wgsl-analyzer.hover.show.enumVariants": {
          "markdownDescription": "How many variants of an enum to display when hovering on. Show none if empty.",
          "default": 5,
          "type": [
            "null",
            "integer"
          ],
          "minimum": 0
        },
        "wgsl-analyzer.hover.show.fields": {
          "markdownDescription": "How many fields of a struct, variant or union to display when hovering on. Show none if empty.",
          "default": 5,
          "type": [
            "null",
            "integer"
          ],
          "minimum": 0
        },
        "wgsl-analyzer.imports.granularity.enforce": {
          "markdownDescription": "Whether to enforce the import granularity setting for all files. If set to false wgsl-analyzer will try to keep import styles consistent per file.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.imports.granularity.group": {
          "markdownDescription": "How imports should be grouped into use statements.",
          "default": "package",
          "type": "string",
          "enum": [
            "preserve",
            "package",
            "module",
            "item",
            "one"
          ],
          "enumDescriptions": [
            "Do not change the granularity of any imports and preserve the original structure written by the developer.",
            "Merge imports from the same package into a single use statement. Conversely, imports from different packages are split into separate statements.",
            "Merge imports from the same module into a single use statement. Conversely, imports from different modules are split into separate statements.",
            "Flatten imports so that each has its own use statement.",
            "Merge all imports into a single use statement as long as they have the same visibility and attributes."
          ]
        },
        "wgsl-analyzer.imports.group.enable": {
          "markdownDescription": "Group inserted imports by the [following order](https://wgsl-analyzer.github.io/book/features.html#auto-import). Groups are separated by newlines.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.imports.preferPrelude": {
          "markdownDescription": "Whether to prefer import paths containing a `prelude` module.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.imports.prefix": {
          "markdownDescription": "The path structure for newly inserted paths to use.",
          "default": "crate",
          "type": "string",
          "enum": [
            "plain",
            "self",
            "package"
          ],
          "enumDescriptions": [
            "Insert import paths relative to the current module, using up to one `super` prefix if the parent module contains the requested item.",
            "Insert import paths relative to the current module, using up to one `super` prefix if the parent module contains the requested item. Prefixes `self` in front of the path if it starts with a module.",
            "Force import paths to be absolute by always starting them with `package` or the extern package name they come from."
          ]
        },
        "wgsl-analyzer.inlayHints.closingBraceHints.enable": {
          "markdownDescription": "Whether to show inlay hints after a closing `}` to indicate what item it belongs to.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.inlayHints.closingBraceHints.minLines": {
          "markdownDescription": "Minimum number of lines required before the `}` until the hint is shown (set to 0 or 1\nto always show them).",
          "default": 25,
          "type": "integer",
          "minimum": 0
        },
        "wgsl-analyzer.inlayHints.discriminantHints.enable": {
          "markdownDescription": "Whether to show enum variant discriminant hints.",
          "default": "never",
          "type": "string",
          "enum": [
            "always",
            "never",
            "fieldless"
          ],
          "enumDescriptions": [
            "Always show all discriminant hints.",
            "Never show discriminant hints.",
            "Only show discriminant hints on fieldless enum variants."
          ]
        },
        "wgsl-analyzer.inlayHints.expressionAdjustmentHints.enable": {
          "markdownDescription": "Whether to show inlay hints for type adjustments.",
          "default": "never",
          "type": "string",
          "enum": [
            "always",
            "never",
            "reborrow"
          ],
          "enumDescriptions": [
            "Always show all adjustment hints.",
            "Never show adjustment hints.",
            "Only show auto borrow and dereference adjustment hints."
          ]
        },
        "wgsl-analyzer.inlayHints.expressionAdjustmentHints.hideOutsideUnsafe": {
          "markdownDescription": "Whether to hide inlay hints for type adjustments outside of `unsafe` blocks.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.inlayHints.expressionAdjustmentHints.mode": {
          "markdownDescription": "Whether to show inlay hints as postfix ops (`.*` instead of `*`, etc).",
          "default": "prefix",
          "type": "string",
          "enum": [
            "prefix",
            "postfix",
            "prefer_prefix",
            "prefer_postfix"
          ],
          "enumDescriptions": [
            "Always show adjustment hints as prefix (`*expr`).",
            "Always show adjustment hints as postfix (`expr.*`).",
            "Show prefix or postfix depending on which uses less parenthesis, preferring prefix.",
            "Show prefix or postfix depending on which uses less parenthesis, preferring postfix."
          ]
        },
        "wgsl-analyzer.inlayHints.genericParameterHints.const.enable": {
          "markdownDescription": "Whether to show const generic parameter name inlay hints.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.inlayHints.genericParameterHints.lifetime.enable": {
          "markdownDescription": "Whether to show generic lifetime parameter name inlay hints.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.inlayHints.genericParameterHints.type.enable": {
          "markdownDescription": "Whether to show generic type parameter name inlay hints.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.inlayHints.implicitDrops.enable": {
          "markdownDescription": "Whether to show implicit drop hints.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.inlayHints.implicitSizedBoundHints.enable": {
          "markdownDescription": "Whether to show inlay hints for the implied type parameter `Sized` bound.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.inlayHints.lifetimeElisionHints.enable": {
          "markdownDescription": "Whether to show inlay type hints for elided lifetimes in function signatures.",
          "default": "never",
          "type": "string",
          "enum": [
            "always",
            "never",
            "skip_trivial"
          ],
          "enumDescriptions": [
            "Always show lifetime elision hints.",
            "Never show lifetime elision hints.",
            "Only show lifetime elision hints if a return type is involved."
          ]
        },
        "wgsl-analyzer.inlayHints.lifetimeElisionHints.useParameterNames": {
          "markdownDescription": "Whether to prefer using parameter names as the name for elided lifetime hints if possible.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.inlayHints.maxLength": {
          "markdownDescription": "Maximum length for inlay hints. Set to null to have an unlimited length.",
          "default": 25,
          "type": [
            "null",
            "integer"
          ],
          "minimum": 0
        },
        "wgsl-analyzer.inlayHints.parameterHints.enable": {
          "markdownDescription": "Whether to show function parameter name inlay hints at the call\nsite.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.inlayHints.rangeExclusiveHints.enable": {
          "markdownDescription": "Whether to show exclusive range inlay hints.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.inlayHints.reborrowHints.enable": {
          "markdownDescription": "Whether to show inlay hints for compiler inserted reborrows.\nThis setting is deprecated in favor of #wgsl-analyzer.inlayHints.expressionAdjustmentHints.enable#.",
          "default": "never",
          "type": "string",
          "enum": [
            "always",
            "never",
            "mutable"
          ],
          "enumDescriptions": [
            "Always show reborrow hints.",
            "Never show reborrow hints.",
            "Only show mutable reborrow hints."
          ]
        },
        "wgsl-analyzer.inlayHints.renderColons": {
          "markdownDescription": "Whether to render leading colons for type hints, and trailing colons for parameter hints.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.inlayHints.typeHints.enable": {
          "markdownDescription": "Whether to show inlay type hints for variables.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.inlayHints.typeHints.hideNamedConstructor": {
          "markdownDescription": "Whether to hide inlay type hints for constructors.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.interpret.tests": {
          "markdownDescription": "Enables the experimental support for interpreting tests.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.joinLines.joinAssignments": {
          "markdownDescription": "Join lines merges consecutive declaration and initialization of an assignment.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.joinLines.joinElseIf": {
          "markdownDescription": "Join lines inserts else between consecutive ifs.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.joinLines.removeTrailingComma": {
          "markdownDescription": "Join lines removes trailing commas.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.joinLines.unwrapTrivialBlock": {
          "markdownDescription": "Join lines unwraps trivial blocks.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.lens.debug.enable": {
          "markdownDescription": "Whether to show `Debug` lens. Only applies when\n`#wgsl-analyzer.lens.enable#` is set.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.lens.enable": {
          "markdownDescription": "Whether to show CodeLens in WGSL files.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.lens.implementations.enable": {
          "markdownDescription": "Whether to show `Implementations` lens. Only applies when\n`#wgsl-analyzer.lens.enable#` is set.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.lens.location": {
          "markdownDescription": "Where to render annotations.",
          "default": "above_name",
          "type": "string",
          "enum": [
            "above_name",
            "above_whole_item"
          ],
          "enumDescriptions": [
            "Render annotations above the name of the item.",
            "Render annotations above the whole item, including documentation comments and attributes."
          ]
        },
        "wgsl-analyzer.lens.references.adt.enable": {
          "markdownDescription": "Whether to show `References` lens for Struct, Enum, and Union.\nOnly applies when `#wgsl-analyzer.lens.enable#` is set.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.lens.references.enumVariant.enable": {
          "markdownDescription": "Whether to show `References` lens for Enum Variants.\nOnly applies when `#wgsl-analyzer.lens.enable#` is set.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.lens.references.method.enable": {
          "markdownDescription": "Whether to show `Method References` lens. Only applies when\n`#wgsl-analyzer.lens.enable#` is set.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.linkedProjects": {
          "markdownDescription": "Disable project auto-discovery in favor of explicitly specified set\nof projects.\n\nElements must be paths pointing to `Wesl.toml`,\n`wgsl-project.json`, `.rs` files (which will be treated as standalone files) or JSON\nobjects in `wgsl-project.json` format.",
          "default": [],
          "type": "array",
          "items": {
            "type": [
              "string",
              "object"
            ]
          }
        },
        "wgsl-analyzer.lru.capacity": {
          "markdownDescription": "Number of syntax trees wgsl-analyzer keeps in memory. Defaults to 128.",
          "default": null,
          "type": [
            "null",
            "integer"
          ],
          "minimum": 0,
          "maximum": 65535
        },
        "wgsl-analyzer.lru.query.capacities": {
          "markdownDescription": "Sets the LRU capacity of the specified queries.",
          "default": {},
          "type": "object"
        },
        "wgsl-analyzer.notifications.weslTomlNotFound": {
          "markdownDescription": "Whether to show `can't find wesl.toml` error message.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.numThreads": {
          "markdownDescription": "How many worker threads in the main loop. The default `null` means to pick automatically.",
          "default": null,
          "anyOf": [
            {
              "type": "null"
            },
            {
              "type": "number",
              "minimum": 0,
              "maximum": 255
            },
            {
              "type": "string",
              "enum": [
                "physical",
                "logical"
              ],
              "enumDescriptions": [
                "Use the number of physical cores",
                "Use the number of logical cores"
              ]
            }
          ]
        },
        "wgsl-analyzer.references.excludeImports": {
          "markdownDescription": "Exclude imports from find-all-references.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.references.excludeTests": {
          "markdownDescription": "Exclude tests from find-all-references and call-hierarchy.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.wgslfmt.extraArgs": {
          "markdownDescription": "Additional arguments to `wgslfmt`.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "wgsl-analyzer.wgslfmt.overrideCommand": {
          "markdownDescription": "Advanced option, fully override the command wgsl-analyzer uses for\nformatting. This should be the equivalent of `wgslfmt` here, and\nnot that of `wesl fmt`. The file contents will be passed on the\nstandard input and the formatted result will be read from the\nstandard output.",
          "default": null,
          "type": [
            "null",
            "array"
          ],
          "items": {
            "type": "string"
          }
        },
        "wgsl-analyzer.wgslfmt.rangeFormatting.enable": {
          "markdownDescription": "Enables the use of wgslfmt's unstable range formatting command for the\n`textDocument/rangeFormatting` request. The wgslfmt option is unstable and only\navailable on a nightly build.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.semanticHighlighting.doc.comment.inject.enable": {
          "markdownDescription": "Inject additional highlighting into doc comments.\n\nWhen enabled, wgsl-analyzer will highlight WGSL source in doc comments as well as intra\ndoc links.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.semanticHighlighting.nonStandardTokens": {
          "markdownDescription": "Whether the server is allowed to emit non-standard tokens and modifiers.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.semanticHighlighting.operator.enable": {
          "markdownDescription": "Use semantic tokens for operators.\n\nWhen disabled, wgsl-analyzer will emit semantic tokens only for operator tokens when\nthey are tagged with modifiers.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.semanticHighlighting.operator.specialization.enable": {
          "markdownDescription": "Use specialized semantic tokens for operators.\n\nWhen enabled, wgsl-analyzer will emit special token types for operator tokens instead\nof the generic `operator` token type.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.semanticHighlighting.punctuation.enable": {
          "markdownDescription": "Use semantic tokens for punctuation.\n\nWhen disabled, wgsl-analyzer will emit semantic tokens only for punctuation tokens when\nthey are tagged with modifiers or have a special role.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.semanticHighlighting.punctuation.specialization.enable": {
          "markdownDescription": "Use specialized semantic tokens for punctuation.\n\nWhen enabled, wgsl-analyzer will emit special token types for punctuation tokens instead\nof the generic `punctuation` token type.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.semanticHighlighting.strings.enable": {
          "markdownDescription": "Use semantic tokens for strings.\n\nIn some editors (e.g. VS Code) semantic tokens override other highlighting grammars.\nBy disabling semantic tokens for strings, other grammars can be used to highlight\ntheir contents.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.signatureInfo.detail": {
          "markdownDescription": "Show full signature of the callable. Only shows parameters if disabled.",
          "default": "full",
          "type": "string",
          "enum": [
            "full",
            "parameters"
          ],
          "enumDescriptions": [
            "Show the entire signature.",
            "Show only the parameters."
          ]
        },
        "wgsl-analyzer.signatureInfo.documentation.enable": {
          "markdownDescription": "Show documentation.",
          "default": true,
          "type": "boolean"
        },
        "wgsl-analyzer.typing.triggerChars": {
          "markdownDescription": "Specify the characters allowed to invoke special on typing triggers.\n- typing `=` after `let` tries to smartly add `;` if `=` is followed by an existing expression\n- typing `=` between two expressions adds `;` when in statement position\n- typing `=` to turn an assignment into an equality comparison removes `;` when in expression position\n- typing `.` in a chain method call auto-indents\n- typing `{` or `(` in front of an expression inserts a closing `}` or `)` after the expression\n- typing `{` in a use item adds a closing `}` in the right place\n- typing `>` to complete a return type `->` will insert a whitespace after it\n- typing `<` in a path or type position inserts a closing `>` after the path or type.",
          "default": "=.",
          "type": [
            "null",
            "string"
          ]
        },
        "wgsl-analyzer.vfs.extraIncludes": {
          "markdownDescription": "Additional paths to include in the VFS. Generally for code that is\ngenerated or otherwise managed by a build system outside of wesl,\nthough wesl might be the eventual consumer.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "wgsl-analyzer.workspace.discoverConfig": {
          "markdownDescription": "Enables automatic discovery of projects using [`DiscoverWorkspaceConfig::command`].\n\n[`DiscoverWorkspaceConfig`] also requires setting `progress_label` and `files_to_watch`.\n`progress_label` is used for the title in progress indicators, whereas `files_to_watch`\nis used to determine which build system-specific files should be watched in order to\nreload wgsl-analyzer.\n\nBelow is an example of a valid configuration:\n```json\n\"wgsl-analyzer.workspace.discoverConfig\": {\n    \"command\": [\n        \"wesl-project\",\n        \"develop-json\"\n    ],\n    \"progressLabel\": \"wgsl-analyzer\",\n    \"filesToWatch\": [\n        \"BUCK\"\n    ]\n}\n```\n\n## On `DiscoverWorkspaceConfig::command`\n\n**Warning**: This format is provisional and subject to change.\n\n[`DiscoverWorkspaceConfig::command`] *must* return a JSON object\ncorresponding to `DiscoverProjectData::Finished`:\n\n```norun\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(tag = \"kind\")]\n#[serde(rename_all = \"snake_case\")]\nenum DiscoverProjectData {\n    Finished { buildfile: Utf8PathBuf, project: ProjectJsonData },\n    Error { error: String, source: Option<String> },\n    Progress { message: String },\n}\n```\n\nAs JSON, `DiscoverProjectData::Finished` is:\n\n```json\n{\n    // the internally-tagged representation of the enum.\n    \"kind\": \"finished\",\n    // the file used by a non-wesl-rs build system to define\n    // a package or target.\n    \"buildfile\": \"wgsl-analyzer/BUILD\",\n    // the contents of a wgsl-project.json, elided for brevity\n    \"project\": {\n        \"sysroot\": \"foo\",\n        \"crates\": []\n    }\n}\n```\n\nIt is encouraged, but not required, to use the other variants on\n`DiscoverProjectData` to provide a more polished end-user experience.\n\n`DiscoverWorkspaceConfig::command` may *optionally* include an `{arg}`,\nwhich will be substituted with the JSON-serialized form of the following\nenum:\n\n```norun\n#[derive(PartialEq, Clone, Debug, Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum DiscoverArgument {\n   Path(AbsPathBuf),\n   Buildfile(AbsPathBuf),\n}\n```\n\nThe JSON representation of `DiscoverArgument::Path` is:\n\n```json\n{\n    \"path\": \"src/main.rs\"\n}\n```\n\nSimilarly, the JSON representation of `DiscoverArgument::Buildfile` is:\n\n```json\n{\n    \"buildfile\": \"BUILD\"\n}\n```\n\n`DiscoverArgument::Path` is used to find and generate a `wgsl-project.json`,\nand therefore, a workspace, whereas `DiscoverArgument::buildfile` is used to\nto update an existing workspace.",
          "default": null,
          "anyOf": [
            {
              "type": "null"
            },
            {
              "type": "object",
              "properties": {
                "command": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "progressLabel": {
                  "type": "string"
                },
                "filesToWatch": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          ]
        },
        "wgsl-analyzer.workspace.symbol.search.excludeImports": {
          "markdownDescription": "Exclude all imports from workspace symbol search.\n\nIn addition to regular imports (which are always excluded),\nthis option removes public imports (better known as re-exports)\nand removes imports that rename the imported symbol.",
          "default": false,
          "type": "boolean"
        },
        "wgsl-analyzer.workspace.symbol.search.kind": {
          "markdownDescription": "Workspace symbol search kind.",
          "default": "only_types",
          "type": "string",
          "enum": [
            "only_types",
            "all_symbols"
          ],
          "enumDescriptions": [
            "Search for types only.",
            "Search for all symbols kinds."
          ]
        },
        "wgsl-analyzer.workspace.symbol.search.limit": {
          "markdownDescription": "Limits the number of items returned from a workspace symbol search (Defaults to 128).\nSome clients like vs-code issue new searches on result filtering and don't require all results to be returned in the initial search.\nOther clients requires all results upfront and might require a higher limit.",
          "default": 128,
          "type": "integer",
          "minimum": 0
        },
        "wgsl-analyzer.workspace.symbol.search.scope": {
          "markdownDescription": "Workspace symbol search scope.",
          "default": "workspace",
          "type": "string",
          "enum": [
            "workspace",
            "workspace_and_dependencies"
          ],
          "enumDescriptions": [
            "Search in current workspace only.",
            "Search in current workspace and dependencies."
          ]
        }
      }
    },
    "commands": [
      {
        "command": "wgsl-analyzer.analyzerStatus",
        "title": "Status",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.memoryUsage",
        "title": "Memory Usage (Clears Database)",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.reloadWorkspace",
        "title": "Reload workspace",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.joinLines",
        "title": "Join lines",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.matchingBrace",
        "title": "Find matching brace",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.openDocs",
        "title": "Open docs under cursor",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.openWeslToml",
        "title": "Open wesl.toml",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.parentModule",
        "title": "Locate parent module",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.reload",
        "title": "Restart server",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.run",
        "title": "Run",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.debug",
        "title": "Debug",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.ssr",
        "title": "Structural Search Replace",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.serverVersion",
        "title": "Show current wgsl-analyzer server version",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.syntaxTree",
        "title": "Show Syntax Tree",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.testCurrent",
        "title": "Test Current",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.install",
        "title": "Install wgsl-analyzer from GitHub release",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.upgrade",
        "title": "Upgrade wgsl-analyzer from GitHub release",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.viewFileText",
        "title": "View File Text (as seen by the server)",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.viewItemTree",
        "title": "Debug ItemTree",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.viewPackageGraph",
        "title": "View Package Graph",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.shufflePackageGraph",
        "title": "Shuffle Package Graph",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.viewFullPackageGraph",
        "title": "View Package Graph (Full)",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.echoRunCommandLine",
        "title": "Echo Run Command Line",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.peekTests",
        "title": "Peek related tests",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.moveItemUp",
        "title": "Move item up",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.moveItemDown",
        "title": "Move item down",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.runFlycheck",
        "title": "Run flycheck",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.cancelFlycheck",
        "title": "Cancel running flychecks",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.clearFlycheck",
        "title": "Clear flycheck diagnostics",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.interpretFunction",
        "title": "Interpret Function",
        "category": "wgsl-analyzer"
      },
      {
        "command": "wgsl-analyzer.explainError",
        "title": "Explain the currently hovered diagnostic",
        "category": "wgsl-analyzer"
      }
    ]
  }
}
